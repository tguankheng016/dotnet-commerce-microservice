//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import moment from 'moment';

export class CategoryServiceProxy {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Update New Category
     * @return OK
     */
    updateCategory(body: EditCategoryDto, signal?: AbortSignal): Promise<UpdateCategoryResult> {
        let url_ = this.baseUrl + "/api/v1/products/category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateCategory(_response);
        });
    }

    protected processUpdateCategory(response: AxiosResponse): Promise<UpdateCategoryResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UpdateCategoryResult.fromJS(resultData200);
            return Promise.resolve<UpdateCategoryResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateCategoryResult>(null as any);
    }

    /**
     * Create New Category
     * @return OK
     */
    createCategory(body: CreateCategoryDto, signal?: AbortSignal): Promise<CreateCategoryResult> {
        let url_ = this.baseUrl + "/api/v1/products/category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateCategory(_response);
        });
    }

    protected processCreateCategory(response: AxiosResponse): Promise<CreateCategoryResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateCategoryResult.fromJS(resultData200);
            return Promise.resolve<CreateCategoryResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateCategoryResult>(null as any);
    }

    /**
     * Get Category By Id
     * @return OK
     */
    getCategoryById(categoryid: number, signal?: AbortSignal): Promise<GetCategoryByIdResult> {
        let url_ = this.baseUrl + "/api/v1/products/category/{categoryid}";
        if (categoryid === undefined || categoryid === null)
            throw new Error("The parameter 'categoryid' must be defined.");
        url_ = url_.replace("{categoryid}", encodeURIComponent("" + categoryid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCategoryById(_response);
        });
    }

    protected processGetCategoryById(response: AxiosResponse): Promise<GetCategoryByIdResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetCategoryByIdResult.fromJS(resultData200);
            return Promise.resolve<GetCategoryByIdResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetCategoryByIdResult>(null as any);
    }

    /**
     * Delete Category
     */
    deleteCategory(categoryid: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/products/category/{categoryid}";
        if (categoryid === undefined || categoryid === null)
            throw new Error("The parameter 'categoryid' must be defined.");
        url_ = url_.replace("{categoryid}", encodeURIComponent("" + categoryid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteCategory(_response);
        });
    }

    protected processDeleteCategory(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get All Categories
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param filters (optional) 
     * @param sorting (optional) 
     * @return OK
     */
    getCategories(skipCount: number | undefined, maxResultCount: number | undefined, filters: string | undefined, sorting: string | undefined, signal?: AbortSignal): Promise<GetCategoriesResult> {
        let url_ = this.baseUrl + "/api/v1/products/categories?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (filters === null)
            throw new Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCategories(_response);
        });
    }

    protected processGetCategories(response: AxiosResponse): Promise<GetCategoriesResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetCategoriesResult.fromJS(resultData200);
            return Promise.resolve<GetCategoriesResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetCategoriesResult>(null as any);
    }
}

export class ProductServiceProxy {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Update New Product
     * @return OK
     */
    updateProduct(body: EditProductDto, signal?: AbortSignal): Promise<UpdateProductResult> {
        let url_ = this.baseUrl + "/api/v1/products/product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateProduct(_response);
        });
    }

    protected processUpdateProduct(response: AxiosResponse): Promise<UpdateProductResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UpdateProductResult.fromJS(resultData200);
            return Promise.resolve<UpdateProductResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateProductResult>(null as any);
    }

    /**
     * Create New Product
     * @return OK
     */
    createProduct(body: CreateProductDto, signal?: AbortSignal): Promise<CreateProductResult> {
        let url_ = this.baseUrl + "/api/v1/products/product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateProduct(_response);
        });
    }

    protected processCreateProduct(response: AxiosResponse): Promise<CreateProductResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateProductResult.fromJS(resultData200);
            return Promise.resolve<CreateProductResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateProductResult>(null as any);
    }

    /**
     * Get All Products
     * @param categoryIdFilter (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param filters (optional) 
     * @param sorting (optional) 
     * @return OK
     */
    getProducts(categoryIdFilter: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined, filters: string | undefined, sorting: string | undefined, signal?: AbortSignal): Promise<GetProductsResult> {
        let url_ = this.baseUrl + "/api/v1/products/products?";
        if (categoryIdFilter === null)
            throw new Error("The parameter 'categoryIdFilter' cannot be null.");
        else if (categoryIdFilter !== undefined)
            url_ += "CategoryIdFilter=" + encodeURIComponent("" + categoryIdFilter) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (filters === null)
            throw new Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProducts(_response);
        });
    }

    protected processGetProducts(response: AxiosResponse): Promise<GetProductsResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetProductsResult.fromJS(resultData200);
            return Promise.resolve<GetProductsResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetProductsResult>(null as any);
    }

    /**
     * Get Product By Id
     * @return OK
     */
    getProductById(productid: number, signal?: AbortSignal): Promise<GetProductByIdResult> {
        let url_ = this.baseUrl + "/api/v1/products/product/{productid}";
        if (productid === undefined || productid === null)
            throw new Error("The parameter 'productid' must be defined.");
        url_ = url_.replace("{productid}", encodeURIComponent("" + productid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProductById(_response);
        });
    }

    protected processGetProductById(response: AxiosResponse): Promise<GetProductByIdResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetProductByIdResult.fromJS(resultData200);
            return Promise.resolve<GetProductByIdResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetProductByIdResult>(null as any);
    }

    /**
     * Delete Product
     */
    deleteProduct(productid: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/products/product/{productid}";
        if (productid === undefined || productid === null)
            throw new Error("The parameter 'productid' must be defined.");
        url_ = url_.replace("{productid}", encodeURIComponent("" + productid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteProduct(_response);
        });
    }

    protected processDeleteProduct(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CategoryDto implements ICategoryDto {
    id!: number;
    creatorUser!: string | undefined;
    creatorUserId!: number | undefined;
    creationTime!: moment.Moment;
    lastModifierUser!: string | undefined;
    lastModifierUserId!: number | undefined;
    lastModificationTime!: moment.Moment | undefined;
    categoryName!: string | undefined;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creatorUser = _data["creatorUser"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.categoryName = _data["categoryName"];
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creatorUser"] = this.creatorUser;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["categoryName"] = this.categoryName;
        return data;
    }

    clone(): CategoryDto {
        const json = this.toJSON();
        let result = new CategoryDto();
        result.init(json);
        return result;
    }
}

export interface ICategoryDto {
    id: number;
    creatorUser: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUser: string | undefined;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    categoryName: string | undefined;
}

export class CreateCategoryDto implements ICreateCategoryDto {
    id!: number | undefined;
    categoryName!: string | undefined;

    constructor(data?: ICreateCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryName = _data["categoryName"];
        }
    }

    static fromJS(data: any): CreateCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryName"] = this.categoryName;
        return data;
    }

    clone(): CreateCategoryDto {
        const json = this.toJSON();
        let result = new CreateCategoryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCategoryDto {
    id: number | undefined;
    categoryName: string | undefined;
}

export class CreateCategoryResult implements ICreateCategoryResult {
    category!: CategoryDto;

    constructor(data?: ICreateCategoryResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"] ? CategoryDto.fromJS(_data["category"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateCategoryResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreateCategoryResult {
        const json = this.toJSON();
        let result = new CreateCategoryResult();
        result.init(json);
        return result;
    }
}

export interface ICreateCategoryResult {
    category: CategoryDto;
}

export class CreateOrEditCategoryDto implements ICreateOrEditCategoryDto {
    id!: number | undefined;
    categoryName!: string | undefined;

    constructor(data?: ICreateOrEditCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryName = _data["categoryName"];
        }
    }

    static fromJS(data: any): CreateOrEditCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryName"] = this.categoryName;
        return data;
    }

    clone(): CreateOrEditCategoryDto {
        const json = this.toJSON();
        let result = new CreateOrEditCategoryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditCategoryDto {
    id: number | undefined;
    categoryName: string | undefined;
}

export class CreateOrEditProductDto implements ICreateOrEditProductDto {
    id!: number | undefined;
    name!: string | undefined;
    description!: string | undefined;
    price!: number | undefined;
    stockQuantity!: number | undefined;
    categoryId!: number | undefined;

    constructor(data?: ICreateOrEditProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.stockQuantity = _data["stockQuantity"];
            this.categoryId = _data["categoryId"];
        }
    }

    static fromJS(data: any): CreateOrEditProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["price"] = this.price;
        data["stockQuantity"] = this.stockQuantity;
        data["categoryId"] = this.categoryId;
        return data;
    }

    clone(): CreateOrEditProductDto {
        const json = this.toJSON();
        let result = new CreateOrEditProductDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditProductDto {
    id: number | undefined;
    name: string | undefined;
    description: string | undefined;
    price: number | undefined;
    stockQuantity: number | undefined;
    categoryId: number | undefined;
}

export class CreateProductDto implements ICreateProductDto {
    id!: number | undefined;
    name!: string | undefined;
    description!: string | undefined;
    price!: number | undefined;
    stockQuantity!: number | undefined;
    categoryId!: number | undefined;

    constructor(data?: ICreateProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.stockQuantity = _data["stockQuantity"];
            this.categoryId = _data["categoryId"];
        }
    }

    static fromJS(data: any): CreateProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["price"] = this.price;
        data["stockQuantity"] = this.stockQuantity;
        data["categoryId"] = this.categoryId;
        return data;
    }

    clone(): CreateProductDto {
        const json = this.toJSON();
        let result = new CreateProductDto();
        result.init(json);
        return result;
    }
}

export interface ICreateProductDto {
    id: number | undefined;
    name: string | undefined;
    description: string | undefined;
    price: number | undefined;
    stockQuantity: number | undefined;
    categoryId: number | undefined;
}

export class CreateProductResult implements ICreateProductResult {
    product!: ProductDto;

    constructor(data?: ICreateProductResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.product = _data["product"] ? ProductDto.fromJS(_data["product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateProductResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreateProductResult {
        const json = this.toJSON();
        let result = new CreateProductResult();
        result.init(json);
        return result;
    }
}

export interface ICreateProductResult {
    product: ProductDto;
}

export class EditCategoryDto implements IEditCategoryDto {
    id!: number | undefined;
    categoryName!: string | undefined;

    constructor(data?: IEditCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryName = _data["categoryName"];
        }
    }

    static fromJS(data: any): EditCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryName"] = this.categoryName;
        return data;
    }

    clone(): EditCategoryDto {
        const json = this.toJSON();
        let result = new EditCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IEditCategoryDto {
    id: number | undefined;
    categoryName: string | undefined;
}

export class EditProductDto implements IEditProductDto {
    id!: number | undefined;
    name!: string | undefined;
    description!: string | undefined;
    price!: number | undefined;
    stockQuantity!: number | undefined;
    categoryId!: number | undefined;

    constructor(data?: IEditProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.stockQuantity = _data["stockQuantity"];
            this.categoryId = _data["categoryId"];
        }
    }

    static fromJS(data: any): EditProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["price"] = this.price;
        data["stockQuantity"] = this.stockQuantity;
        data["categoryId"] = this.categoryId;
        return data;
    }

    clone(): EditProductDto {
        const json = this.toJSON();
        let result = new EditProductDto();
        result.init(json);
        return result;
    }
}

export interface IEditProductDto {
    id: number | undefined;
    name: string | undefined;
    description: string | undefined;
    price: number | undefined;
    stockQuantity: number | undefined;
    categoryId: number | undefined;
}

export class GetCategoriesResult implements IGetCategoriesResult {
    items!: CategoryDto[] | undefined;
    totalCount!: number;

    constructor(data?: IGetCategoriesResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CategoryDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetCategoriesResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetCategoriesResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): GetCategoriesResult {
        const json = this.toJSON();
        let result = new GetCategoriesResult();
        result.init(json);
        return result;
    }
}

export interface IGetCategoriesResult {
    items: CategoryDto[] | undefined;
    totalCount: number;
}

export class GetCategoryByIdResult implements IGetCategoryByIdResult {
    category!: CreateOrEditCategoryDto;

    constructor(data?: IGetCategoryByIdResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"] ? CreateOrEditCategoryDto.fromJS(_data["category"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCategoryByIdResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetCategoryByIdResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetCategoryByIdResult {
        const json = this.toJSON();
        let result = new GetCategoryByIdResult();
        result.init(json);
        return result;
    }
}

export interface IGetCategoryByIdResult {
    category: CreateOrEditCategoryDto;
}

export class GetProductByIdResult implements IGetProductByIdResult {
    product!: CreateOrEditProductDto;

    constructor(data?: IGetProductByIdResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.product = _data["product"] ? CreateOrEditProductDto.fromJS(_data["product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetProductByIdResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductByIdResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetProductByIdResult {
        const json = this.toJSON();
        let result = new GetProductByIdResult();
        result.init(json);
        return result;
    }
}

export interface IGetProductByIdResult {
    product: CreateOrEditProductDto;
}

export class GetProductsResult implements IGetProductsResult {
    items!: ProductDto[] | undefined;
    totalCount!: number;

    constructor(data?: IGetProductsResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetProductsResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductsResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): GetProductsResult {
        const json = this.toJSON();
        let result = new GetProductsResult();
        result.init(json);
        return result;
    }
}

export interface IGetProductsResult {
    items: ProductDto[] | undefined;
    totalCount: number;
}

export class ProblemDetails implements IProblemDetails {
    type!: string | undefined;
    title!: string | undefined;
    status!: number | undefined;
    detail!: string | undefined;
    instance!: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }

    clone(): ProblemDetails {
        const json = this.toJSON();
        let result = new ProblemDetails();
        result.init(json);
        return result;
    }
}

export interface IProblemDetails {
    type: string | undefined;
    title: string | undefined;
    status: number | undefined;
    detail: string | undefined;
    instance: string | undefined;

    [key: string]: any;
}

export class ProductDto implements IProductDto {
    id!: number;
    creatorUser!: string | undefined;
    creatorUserId!: number | undefined;
    creationTime!: moment.Moment;
    lastModifierUser!: string | undefined;
    lastModifierUserId!: number | undefined;
    lastModificationTime!: moment.Moment | undefined;
    name!: string | undefined;
    description!: string | undefined;
    price!: number;
    stockQuantity!: number;
    categoryId!: number | undefined;
    categoryName!: string | undefined;

    constructor(data?: IProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creatorUser = _data["creatorUser"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.stockQuantity = _data["stockQuantity"];
            this.categoryId = _data["categoryId"];
            this.categoryName = _data["categoryName"];
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creatorUser"] = this.creatorUser;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["description"] = this.description;
        data["price"] = this.price;
        data["stockQuantity"] = this.stockQuantity;
        data["categoryId"] = this.categoryId;
        data["categoryName"] = this.categoryName;
        return data;
    }

    clone(): ProductDto {
        const json = this.toJSON();
        let result = new ProductDto();
        result.init(json);
        return result;
    }
}

export interface IProductDto {
    id: number;
    creatorUser: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUser: string | undefined;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    name: string | undefined;
    description: string | undefined;
    price: number;
    stockQuantity: number;
    categoryId: number | undefined;
    categoryName: string | undefined;
}

export class UpdateCategoryResult implements IUpdateCategoryResult {
    category!: CategoryDto;

    constructor(data?: IUpdateCategoryResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"] ? CategoryDto.fromJS(_data["category"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateCategoryResult {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        return data;
    }

    clone(): UpdateCategoryResult {
        const json = this.toJSON();
        let result = new UpdateCategoryResult();
        result.init(json);
        return result;
    }
}

export interface IUpdateCategoryResult {
    category: CategoryDto;
}

export class UpdateProductResult implements IUpdateProductResult {
    product!: ProductDto;

    constructor(data?: IUpdateProductResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.product = _data["product"] ? ProductDto.fromJS(_data["product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateProductResult {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data;
    }

    clone(): UpdateProductResult {
        const json = this.toJSON();
        let result = new UpdateProductResult();
        result.init(json);
        return result;
    }
}

export interface IUpdateProductResult {
    product: ProductDto;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}